var documenterSearchIndex = {"docs":
[{"location":"query.html#query","page":"Spatial Queries","title":"Spatial Queries","text":"","category":"section"},{"location":"query.html","page":"Spatial Queries","title":"Spatial Queries","text":"SpatialIndexing.SpatialQueryIterator\nSpatialIndexing.QueryKind\nSpatialIndexing.QueryMatch","category":"page"},{"location":"query.html#SpatialIndexing.SpatialQueryIterator","page":"Spatial Queries","title":"SpatialIndexing.SpatialQueryIterator","text":"Base abstract class for implementing spatial queries in N-dimensional space.\n\n\n\n\n\n","category":"type"},{"location":"query.html#SpatialIndexing.QueryKind","page":"Spatial Queries","title":"SpatialIndexing.QueryKind","text":"Specifies the kind of spatial data query.\n\n\n\n\n\n","category":"type"},{"location":"query.html#SpatialIndexing.QueryMatch","page":"Spatial Queries","title":"SpatialIndexing.QueryMatch","text":"Specifies the result of spatial data query.\n\n\n\n\n\n","category":"type"},{"location":"query.html","page":"Spatial Queries","title":"Spatial Queries","text":"Base.findfirst\nBase.isempty","category":"page"},{"location":"query.html#Base.findfirst","page":"Spatial Queries","title":"Base.findfirst","text":"findfirst(tree::RTree{T,N}, reg::Region{T,N}, [id]) where {T,N}\n\nFind the element in the tree by its region (reg) and, optionally, its id. The region (MBR) of the element and reg should match exactly.\n\nReturns the tuple of Leaf and position of the element or nothing.\n\n\n\n\n\n","category":"function"},{"location":"query.html#Base.isempty","page":"Spatial Queries","title":"Base.isempty","text":"isempty(tree::RTree, region::Region)\n\nCheck if there are tree elements inside region.\n\n\n\n\n\n","category":"function"},{"location":"query.html","page":"Spatial Queries","title":"Spatial Queries","text":"contained_in\nintersects_with","category":"page"},{"location":"query.html#SpatialIndexing.contained_in","page":"Spatial Queries","title":"SpatialIndexing.contained_in","text":"contained_in(index::SpatialIndex, region::Region)\n\nGet iterator for index elements contained in region.\n\n\n\n\n\n","category":"function"},{"location":"query.html#SpatialIndexing.intersects_with","page":"Spatial Queries","title":"SpatialIndexing.intersects_with","text":"intersects_with(index::SpatialIndex, region::Region)\n\nGet iterator for index elements intersecting with region.\n\n\n\n\n\n","category":"function"},{"location":"rtree.html#rtree","page":"R-tree","title":"R-tree","text":"","category":"section"},{"location":"rtree.html","page":"R-tree","title":"R-tree","text":"R-tree organizes data into hierarchical structure and ensures that:","category":"page"},{"location":"rtree.html","page":"R-tree","title":"R-tree","text":"minimal bounding rectangles (MBRs) of the nodes (rectangles that encompass all data elements in the subtree) stay compact,\nMBRs of the nodes from the same R-tree level have minimal overlap with each other.","category":"page"},{"location":"rtree.html","page":"R-tree","title":"R-tree","text":"The key benefit of R-tree is its ability to rebalance itself and maintain efficient structure while handling dynamic data (massive insertions and deletions).","category":"page"},{"location":"rtree.html","page":"R-tree","title":"R-tree","text":"SpatialIndexing provides RTree type that supports:","category":"page"},{"location":"rtree.html","page":"R-tree","title":"R-tree","text":"different R-tree variants (classic R-tree, R*-tree, linear and quadratic node splits)\ninsert!(tree, item), delete!(tree, item) for element-wise insertion and deletion\nbulk-loading of data using Overlap-minimizing Top-down (OMT) approach (load!(tree, data))\nsubtract!(tree, reg) for removing data within specified region reg\nfindfirst(tree, reg, [id]), contained_in(tree, reg) and intersects_with(tree, reg) spatial queries","category":"page"},{"location":"rtree.html","page":"R-tree","title":"R-tree","text":"RTree\nSpatialIndexing.RTreeVariant\nBase.insert!\nBase.delete!","category":"page"},{"location":"rtree.html#SpatialIndexing.RTree","page":"R-tree","title":"SpatialIndexing.RTree","text":"R-Tree: N-dimensional spatial data index [guttman84].\n\nR-tree groups data elements (V) into leaves (Leaf) and leaves into branches (Branch). It uses various heuristics to ensure that the minimal bounding rectangles (MBRs) of the nodes (Rect{T,N} rectangles that encompass the data elements attached to these nodes) stay compact and that the MBRs of the nodes that are on the same level of R-tree hierarchy have minimal overlap with each other. This property makes R-trees efficient for spatial queries.\n\nTo facilitate spatial indexing, the V data elements need to support HasMBR trait (i.e. define mbrtype(V) and mbr(v::V) methods) and, optionally, HasID trait (via idtype(V) and id(v::V) methods). mbr(v::V) should return minimal bounding rectangle (MBR) of type Rect{T,N} that contains v. SpatialElem{T,N,D} type provides generic implementation of spatial data element that explicitly stores id, mbr and data object of type D and implements HasMBR and HasID traits.\n\nParameters\n\nThe behaviour of RTree is defined by the parameters supplied at its creation:\n\nT: the numeric type for the spatial coordinate\nN: the number of spatial dimensions\nvariant: one of RTreeLinear, RTreeQuadratic, or RTreeStar (default)\ntight_mbrs: recalculate node MBR when the child is removed (default is true)\nbranch_capacity: capacity of branch nodes (default is 100)\nleaf_capacity: capacity of leaf nodes (default is 100)\nleafpool_capacity: How many detached 1st level nodes (leaves) should be kept for reuse (default is 100)\ntwigpool_capacity: How many detached 2nd level nodes should be kept for reuse (default is 100)\nbranchpool_capacity: How many other (level > 2) detached branch nodes should be kept for reuse (default is 100)\nnearmin_overlap: How many candidates to consider when identifying the node with minimal overlap (default is 32)\nfill_factor: How much should the node be filled (fraction of its capacity) after splitting (default is 0.7)\nsplit_factor: How much can the sizes of the two nodes differ after splitting (default is 0.4)\nreinsert_factor: How much should the node be underfilled (fraction of its capacity) to consider removing it and redistributing its children to other nodes (default is 0.3)\n\nPerformance\n\nThe nodes in R-tree have limited capacity (maximual number of children) specified at RTree creation (leaf_capacity and branch_capacity). Larger capacities results in shorter trees, but they time required to locate the specific spatial region grows linearly with the capacity.\n\nReferences\n\n[guttman84] “R-Trees: A Dynamic Index Structure for Spatial Searching”     A. Guttman, Proc. 1984 ACM-SIGMOD Conference on Management of     Data (1985), 47-57. [beckmann90] \"The R*-tree: an efficient and robust access method for points and rectangles\"     N. Beckmann, H.P. Kriegel, R. Schneider, B. Seeger, Proc. 1990 ACM SIGMOD     international conference on Management of data (1990), p.322\n\n\n\n\n\n","category":"type"},{"location":"rtree.html#SpatialIndexing.RTreeVariant","page":"R-tree","title":"SpatialIndexing.RTreeVariant","text":"R-Tree variants.\n\n\n\n\n\n","category":"type"},{"location":"rtree.html#Base.insert!","page":"R-tree","title":"Base.insert!","text":"insert!(tree::RTree, pt::Point, [id], val)\ninsert!(tree::RTree, br::Rect, [id], val)\ninsert!(tree::RTree, elem::SpatialElem)\n\nInserts val value identified by br bounding box (or point pt) and id (if tree elememnts support HasID trait) into the tree.\n\n\n\n\n\n","category":"function"},{"location":"rtree.html#Base.delete!","page":"R-tree","title":"Base.delete!","text":"delete!(tree::RTree, pt::Point, [id])\ndelete!(tree::RTree, br::Rect, [id])\n\nDeletes the value identified by br bounding box (or point pt) and the id (if tree elements support HasID trait) from the tree.\n\n\n\n\n\n","category":"function"},{"location":"abstract.html#abstract","page":"Basic Spatial Types","title":"Basic Spatial Types","text":"","category":"section"},{"location":"abstract.html","page":"Basic Spatial Types","title":"Basic Spatial Types","text":"SpatialIndex\nSpatialElem\nSpatialIndexing.HasMBR\nSpatialIndexing.HasID\nSpatialIndexException\n\nSpatialIndexing.subtract!\nSpatialIndexing.load!","category":"page"},{"location":"abstract.html#SpatialIndexing.SpatialIndex","page":"Basic Spatial Types","title":"SpatialIndexing.SpatialIndex","text":"Base abstract class for spatial indexing of elements of type V in N-dimensional space with dimensions of type T.\n\n\n\n\n\n","category":"type"},{"location":"abstract.html#SpatialIndexing.SpatialElem","page":"Basic Spatial Types","title":"SpatialIndexing.SpatialElem","text":"Simple N-dimensional spatial data element that stores values of type V and could be referenced by the id of type K (if K is not Nothing).\n\nSupports HasMBR{Rect{T,N}} and HasID{K} (if K is not Nothing) traits.\n\n\n\n\n\n","category":"type"},{"location":"abstract.html#SpatialIndexing.HasMBR","page":"Basic Spatial Types","title":"SpatialIndexing.HasMBR","text":"Type trait for checking mbr() method support. If type V has this trait (mbrtype(V) returns HasMBR{Rect{T,N}}), then mbr(v::V) should return a minimal bounding rectangle (MBR) Rect{T,N} that contains v. If V doesn't have this trait, mbrtype(V) returns HasNoMBR.\n\nSpatialIndex{T,N,V} requires that V provides mbr() method that returns Rect{T,N}.\n\n\n\n\n\n","category":"type"},{"location":"abstract.html#SpatialIndexing.HasID","page":"Basic Spatial Types","title":"SpatialIndexing.HasID","text":"Type trait for checking id() method support. If type V has this trait (idtype(V) returns HasID{K}), then id(v::V) should return a unique identifier for v of type K. If V doesn't have this trait, idtype(V) returns HasNoID.\n\nIf available, SpatialIndex{T,N,V} uses unique identifiers of V alongside spatial indexing.\n\n\n\n\n\n","category":"type"},{"location":"abstract.html#SpatialIndexing.SpatialIndexException","page":"Basic Spatial Types","title":"SpatialIndexing.SpatialIndexException","text":"SpatialIndex-related exception raised within Julia\n\n\n\n\n\n","category":"type"},{"location":"abstract.html#SpatialIndexing.subtract!","page":"Basic Spatial Types","title":"SpatialIndexing.subtract!","text":"subtract!(tree::RTree, reg::Region)\n\nSubtracts the region from the tree, i.e. removes all elements within region.\n\n\n\n\n\n","category":"function"},{"location":"abstract.html#SpatialIndexing.load!","page":"Basic Spatial Types","title":"SpatialIndexing.load!","text":"load!(tree::RTree{T,N,V}, data::Any;\n      convertel = identity, method = :OMT,\n      leaf_fill = capacity(Leaf, tree),\n      branch_fill::Tuple{Integer, Integer} = omt_branch_fill(tree)) where {T,N,V}\n\nBulk-load data into tree.\n\ntree: an empty R-tree for storing elements of type V\ndata: iterable container with the elements to put into tree\nconvertel: function to convert elements of data to type V\nmethod: bulk-loading method\nleaf_fill: the average number of elements to store in R-tree leaves (1-level nodes)\nbranch_fill: the tuple of the number of slices and the number of subtrees per slice in the R-tree nodes (level ≥ 1).\n\nThe supported bulk-loading methods are:\n\n:OMT: Overlap Minimizing Top-down method by Taewon Lee and Sukho Lee\n\n\n\n\n\n","category":"function"},{"location":"regions.html#regions","page":"Spatial Primitives","title":"Spatial Primitives","text":"","category":"section"},{"location":"regions.html","page":"Spatial Primitives","title":"Spatial Primitives","text":"SpatialIndexing.Region\nSpatialIndexing.Point\nSpatialIndexing.Rect\n\nSpatialIndexing.empty\nSpatialIndexing.isvalid\nSpatialIndexing.center\nSpatialIndexing.area\nSpatialIndexing.perimeter\n\nSpatialIndexing.intersects\nSpatialIndexing.contains\nSpatialIndexing.touches\nBase.in\n\nSpatialIndexing.overlap_area\nSpatialIndexing.combined_area\nSpatialIndexing.enlargement\n\nSpatialIndexing.combine\nSpatialIndexing.intersect","category":"page"},{"location":"regions.html#SpatialIndexing.Region","page":"Spatial Primitives","title":"SpatialIndexing.Region","text":"Base abstract class for implementing regions in N-dimensional space with dimensions of type T.\n\n\n\n\n\n","category":"type"},{"location":"regions.html#SpatialIndexing.Point","page":"Spatial Primitives","title":"SpatialIndexing.Point","text":"N-dimensional point.\n\n\n\n\n\n","category":"type"},{"location":"regions.html#SpatialIndexing.Rect","page":"Spatial Primitives","title":"SpatialIndexing.Rect","text":"Rectangular region constrained by low[i]...high[i] in each of N dimensions.\n\n\n\n\n\n","category":"type"},{"location":"regions.html#SpatialIndexing.empty","page":"Spatial Primitives","title":"SpatialIndexing.empty","text":"empty(::Type{T}) where T<:Region\n\nGenerate empty (uninitialized) region of type T.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.isvalid","page":"Spatial Primitives","title":"SpatialIndexing.isvalid","text":"isvalid(a::Region)\n\nCheck that the parameters of a are valid and it defines a proper region.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.center","page":"Spatial Primitives","title":"SpatialIndexing.center","text":"center(a::Region)\n\nThe center point of a.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.area","page":"Spatial Primitives","title":"SpatialIndexing.area","text":"area(a::Region)\n\nN-dimensional \"area\" (volume etc) of a.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.perimeter","page":"Spatial Primitives","title":"SpatialIndexing.perimeter","text":"perimeter(a::Region)\n\nThe sum of the a sides.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.intersects","page":"Spatial Primitives","title":"SpatialIndexing.intersects","text":"intersects(a::Region, b::Region)\n\nCheck whether a intersects with b.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.contains","page":"Spatial Primitives","title":"SpatialIndexing.contains","text":"contains(a::Region, b::Region)\n\nCheck whether a contains b.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.touches","page":"Spatial Primitives","title":"SpatialIndexing.touches","text":"touches(a::Rect, b::Rect)\n\nCheck whether a and b rectangles touches from the inside (i.e. any low side touches low or high touches high).\n\n\n\n\n\n","category":"function"},{"location":"regions.html#Base.in","page":"Spatial Primitives","title":"Base.in","text":"in(a::Region, b::Region)\n\nCheck whether a is contained inside b.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.overlap_area","page":"Spatial Primitives","title":"SpatialIndexing.overlap_area","text":"overlap_area(a::Region, b::Region)\n\nThe area of MBR for a and b intersection.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.combined_area","page":"Spatial Primitives","title":"SpatialIndexing.combined_area","text":"combined_area(a::Region, b::Region)\n\nThe area of MBR for the union of a and b.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.enlargement","page":"Spatial Primitives","title":"SpatialIndexing.enlargement","text":"enlargement(a::Region, b::Region)\n\nHow much a grows when combined with b.\n\nThe difference between the MBR area of the a and b union and the MBR area of a.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.combine","page":"Spatial Primitives","title":"SpatialIndexing.combine","text":"combine(a::Region, b::Region)\n\nMBR that contains both a and b regions.\n\n\n\n\n\n","category":"function"},{"location":"regions.html#SpatialIndexing.intersect","page":"Spatial Primitives","title":"SpatialIndexing.intersect","text":"intersect(a::Region, b::Region)\n\nMBR that is an intersection of a and b regions.\n\n\n\n\n\n","category":"function"},{"location":"simple.html#simple_index","page":"Simple Spatial Index","title":"Simple Spatial Index","text":"","category":"section"},{"location":"simple.html","page":"Simple Spatial Index","title":"Simple Spatial Index","text":"SimpleSpatialIndex stores all data elements in a vector. So, while insertion of new data takes constant time, the time of spatial searches grows linearly with the number of elements. This spatial index is intended as a reference implementation for benchmarking and not recommended for production usage.","category":"page"},{"location":"simple.html","page":"Simple Spatial Index","title":"Simple Spatial Index","text":"SimpleSpatialIndex","category":"page"},{"location":"simple.html#SpatialIndexing.SimpleSpatialIndex","page":"Simple Spatial Index","title":"SpatialIndexing.SimpleSpatialIndex","text":"Vector-based SpatialIndex. While insertion is O(1), the search is O(N).\n\nGenerally should not be used, except for performance comparisons or when the number of stored elements is expected to be very small (<100).\n\n\n\n\n\n","category":"type"},{"location":"index.html#SpatialIndexing.jl-package","page":"Introduction","title":"SpatialIndexing.jl package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"SpatialIndexing package provides the tools for efficient in-memory storage and retrieval of spatial data in Julia (http://julialang.org/).","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"SpatialIndexing\")","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"from Julia REPL.","category":"page"},{"location":"index.html#Spatial-Indices","page":"Introduction","title":"Spatial Indices","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"spatial primitives\nbasic types\nR-tree, R*-tree\nsimple index\nspatial queries","category":"page"},{"location":"index.html#See-also","page":"Introduction","title":"See also","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Other Julia packages for spatial data:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"LibSpatialIndex.jl (libspatialindex wrapper)\nNearestNeighbors.jl\nRegionTrees.jl\nLSH.jl","category":"page"},{"location":"index.html#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A.Guttman, “R-Trees: A Dynamic Index Structure for Spatial Searching” Proc. 1984 ACM-SIGMOD Conference on Management of Data (1985), pp.47-57.\nN. Beckmann, H.P. Kriegel, R. Schneider, B. Seeger, \"The R*-tree: an efficient and robust access method for points and rectangles\" Proc. 1990 ACM SIGMOD international conference on Management of data (1990), p.322\nT. Lee and S. Lee, \"OMT: Overlap Minimizing Top-down Bulk Loading Algorithm for R-tree\", CAiSE Short Paper Proceedings (2003) paper","category":"page"}]
}
